# ECS アーキテクチャ図

## 構成図

```mermaid
graph TB
    Internet[インターネット] --> ALB[ALB<br/>yuria-alb<br/>Port: 80/443]
    
    subgraph VPC["VPC: 10.0.0.0/16"]
        subgraph PublicSubnet1["Public Subnet 1<br/>10.0.1.0/24<br/>ap-northeast-1a"]
            ALB
        end
        
        subgraph PublicSubnet2["Public Subnet 2<br/>10.0.2.0/24<br/>ap-northeast-1c"]
        end
        
        ALB --> Listener[リスナー: HTTP 80<br/>デフォルト → webapp-target-group]
        Listener --> Rule1[ルール優先度1<br/>パス: /api/*]
        Listener --> DefaultAction[デフォルトアクション<br/>パス: /*]
        
        Rule1 --> BotappTG[botapp-target-group<br/>Port: 5000<br/>ヘルスチェック: GET /api/healthCheck]
        DefaultAction --> WebappTG[webapp-target-group<br/>Port: 3000<br/>ヘルスチェック: GET /]
        
        subgraph ECSCluster["ECS Cluster: yuria-cluster<br/>起動タイプ: Fargate"]
            subgraph WebappService["webapp-service<br/>desired count: 1<br/>セキュリティグループ: ECSSecurityGroup"]
                WebappTask[タスク: webapp-task<br/>vCPU: 0.25<br/>メモリ: 512MB<br/>ログ: /ecs/webapp]
                WebappContainer[コンテナ: webapp<br/>ポート: 3000<br/>イメージ: ECR yuria/webapp:latest]
            end
            
            subgraph BotappService["botapp-service<br/>desired count: 1<br/>セキュリティグループ: ECSSecurityGroup"]
                BotappTask[タスク: botapp-task<br/>vCPU: 0.25<br/>メモリ: 512MB<br/>ログ: /ecs/botapp]
                BotappContainer[コンテナ: botapp<br/>ポート: 5000<br/>イメージ: ECR yuria/botapp:latest]
            end
        end
        
        WebappTG --> WebappTask
        BotappTG --> BotappTask
        WebappTask --> WebappContainer
        BotappTask --> BotappContainer
    end
    
    subgraph ECR["ECR: Elastic Container Registry"]
        ECR1[リポジトリ: yuria/webapp<br/>イメージタグ: latest]
        ECR2[リポジトリ: yuria/botapp<br/>イメージタグ: latest]
    end
    
    ECR1 -.プル.-> WebappContainer
    ECR2 -.プル.-> BotappContainer
    
    subgraph IAM["IAM Roles"]
        TaskExecutionRole[ecsTaskExecutionRole<br/>- AmazonECSTaskExecutionRolePolicy<br/>- ECRからイメージプル<br/>- CloudWatch Logsへ書き込み]
    end
    
    TaskExecutionRole -.使用.-> WebappTask
    TaskExecutionRole -.使用.-> BotappTask
    
    subgraph CloudWatch["CloudWatch Logs"]
        WebappLogs[ロググループ: /ecs/webapp]
        BotappLogs[ロググループ: /ecs/botapp]
    end
    
    WebappContainer -.ログ出力.-> WebappLogs
    BotappContainer -.ログ出力.-> BotappLogs
    
    subgraph SecurityGroups["セキュリティグループ"]
        ALBSG[ALBSecurityGroup<br/>インバウンド:<br/>- HTTP 80 from 0.0.0.0/0<br/>- HTTPS 443 from 0.0.0.0/0]
        ECSSG[ECSSecurityGroup<br/>インバウンド:<br/>- Port 3000 from ALBSecurityGroup<br/>- Port 5000 from ALBSecurityGroup]
    end
    
    ALBSG --> ALB
    ECSSG --> WebappTask
    ECSSG --> BotappTask
    
    style ECR1 fill:#ff9900
    style ECR2 fill:#ff9900
    style ALB fill:#326CE5
    style ECSCluster fill:#FF9900
    style VPC fill:#E8F5E9
    style WebappService fill:#FFF3E0
    style BotappService fill:#FFF3E0
    style IAM fill:#DD4B39
    style CloudWatch fill:#FF4F8B
```

## コンポーネント詳細

### ECR (Elastic Container Registry)
- `yuria/webapp` - Next.jsアプリのイメージ
- `yuria/botapp` - Botアプリのイメージ

### ECSクラスター: yuria-cluster
1つのクラスターで複数のサービスを管理

#### サービス1: webapp-service
- タスク定義: webapp-task
- desired count: 1
- コンテナポート: 3000

#### サービス2: botapp-service
- タスク定義: botapp-task
- desired count: 1
- コンテナポート: 5000

### ALB (Application Load Balancer)
パスベースルーティング:
- `/*` → webapp-target-group → webappコンテナ
- `/api/*` → botapp-target-group → botappコンテナ

### ターゲットグループ
- webapp-target-group: 
  - ポート: 3000
  - ヘルスチェック: GET `/` (HTTPステータス200期待)
- botapp-target-group: 
  - ポート: 5000
  - ヘルスチェック: GET `/api/healthCheck` (HTTPステータス200期待)

## データフロー

1. ユーザーがALBにアクセス
2. ALBがパスを見て適切なターゲットグループに転送
3. ターゲットグループが対応するECSタスクに転送
4. タスク（コンテナ）がリクエストを処理
5. レスポンスを返す

## デプロイフロー

1. ローカルでDockerイメージをビルド
2. ECRにプッシュ
3. ECSサービスを更新（force-new-deployment）
4. 新しいタスクが起動し、古いタスクと入れ替わる
